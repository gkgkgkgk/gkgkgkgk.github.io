---
layout: post
title: "Boids and Compute Shaders"
date: 2022-1-19 11:45:00 -0000
categories: shaders
featured-image: https://raw.githubusercontent.com/gkgkgkgk/gkgkgkgk.github.io/gh-pages/_posts/assets/boids/biggif.gif
---

## What are Boids?
The word Boid comes from a shortened version of "bird-oid object", a term to describe a bird-like object. Just as standard issue birds are programmed to fly around in a flock, boids follow three simple rules to emulate that behaviour.
* Alignment: every boid attempts to fly in the same direction as other nearby boids
* Cohesion: boids attempt to stay together
* Avoidance: boids try not to crash into each other

The actual algorithm will be discussed in depth later on. Before I jump into the technical details, let's take a look at some boids in action! The simulation below is a very simple implementation of boids. Feel free to play around with it to see what each of the sliders do!

## Simple Boid Simulation
<head>
    <link rel="stylesheet" href="styles.css">
</head>
<canvas id="myCanvas" width="500" height="500" style="border:1px solid #000000;">
</canvas>

<div>
    <h4>Amount of Boids</h4>
    <p>This slider will change the amount of boids in the simulation.</p>
    <div class='sliderContainer'>
        <input type="range" min="0" max="500" value="50" oninput="changeBoidAmount(this.value)" />
    </div>
</div>
<h4>Boid Rules</h4>
<p>Each weight slider determines how important each rule is to the boids, while rach range slider determines how close the boids have to be to each other in order to adhere to that rule.</p>
<div>
    <h4>Cohesion</h4>
    <div class='sliderContainer'>
        <span class='slider' id="cohesion">Weight</span>
        <input type="range" min="0" max="50" value="5" oninput="changeCohesionWeight(this.value)" />
        <span class='slider' id="cohesion">Range</span>
        <input type="range" min="1" max="750" value="250" oninput="changeCohesionRange(this.value)" />
    </div>
</div>

<div>
    <h4>Alignment</h4>
    <div class='sliderContainer'>
        <span class='slider'>Weight</span>
        <input type="range" min="0" max="50" value="5" oninput="changeAlignmentWeight(this.value)" />
        <span class='slider'>Range</span>
        <input type="range" min="1" max="750" value="250" oninput="changeAlignmentRange(this.value)" />
    </div>
</div>

<div>
    <h4>Avoidence</h4>
    <div class='sliderContainer'>
        <span class='slider'>Weight</span>
        <input type="range" min="0" max="500" value="50" oninput="changeAvoidenceWeight(this.value)" />
        <span class='slider'>Range</span>
        <input type="range" min="1" max="50" value="20" oninput="changeAvoidenceRange(this.value)" />
    </div>
</div>

<script>
    var c = document.getElementById("myCanvas");
    var ctx = c.getContext("2d");

    var mouse = {
        x: undefined,
        y: undefined
    };

    c.addEventListener("mousemove", function (e) {
        mouse.x = e.x;
        mouse.y = e.y;
        var rect = c.getBoundingClientRect();
        mouse.x -= rect.left;
        mouse.y -= rect.top;
    });

    let cohesionWeight = 0.0025;
    const changeCohesionWeight = (cohesion) => {
        cohesionWeight = cohesion / 1000;
    };

    let cohesionRange = 250;
    const changeCohesionRange = (cohesion) => {
        cohesionRange = cohesion;
    };

    let alignmentWeight = 0.026;
    const changeAlignmentWeight = (alignment) => {
        alignmentWeight = alignment / 1000;
    };

    let alignmentRange = 25;
    const changeAlignmentRange = (alignment) => {
        alignmentRange = alignment;
    };

    let avoidenceWeight = 0.104;
    const changeAvoidenceWeight = (avoidence) => {
        avoidenceWeight = avoidence / 1000;
    };

    let avoidenceRange = 5;
    const changeAvoidenceRange = (avoidence) => {
        avoidenceRange = avoidence;
    };

    let boidAmount = 100;
    const changeBoidAmount = (amt) => {
        boidAmount = amt;
    };

    const initBoids = (amount) => {
        let boids = [];
        for (let i = 0; i < amount; i++) {
            let xPos = Math.random() * c.width;
            let yPos = Math.random() * c.height;
            let speed = 1;
            let dx = Math.random() * 20 - 10;
            let dy = Math.random() * 20 - 10;
            let rot = Math.atan2(dy, dx);

            boids.push({
                name: "boid" + i,
                x: xPos,
                y: yPos,
                dx: dx,
                dy: dy,
                rot: rot,
                speed: speed,
                color: '#' + Math.floor(Math.random() * 16777215).toString(16)
            });
        }

        return boids;
    }

    const drawBoid = (boid) => {
        ctx.save();
        ctx.translate(boid.x, boid.y);
        ctx.rotate(Math.atan2(boid.dy, boid.dx));
        ctx.beginPath();
        ctx.moveTo(-2, 2);
        ctx.lineTo(-2, -2);
        ctx.lineTo(4, 0);

        ctx.closePath();
        ctx.stroke();
        ctx.fill();
        ctx.restore();
    }

    const distance = (boid1, boid2) => {
        return Math.sqrt(Math.pow(boid1.x - boid2.x, 2) + Math.pow(boid1.y - boid2.y, 2));
    }

    const cohesion = (boid) => {
        let cohesionX = 0;
        let cohesionY = 0;
        let amt = 0;

        for (let i = 0; i < boids.length; i++) {
            if (distance(boid, boids[i]) < cohesionRange && boid.name != boids[i].name) {
                cohesionX += boids[i].x;
                cohesionY += boids[i].y;
                amt++;
            }
        }

        if (amt > 0) {
            cohesionX = cohesionX / amt;
            cohesionY = cohesionY / amt;
            boid.dx += ((cohesionX - boid.x) * cohesionWeight);
            boid.dy += ((cohesionY - boid.y) * cohesionWeight);
        }
    }

    const avoidence = (boid) => {
        let avoidenceX = 0;
        let avoidenceY = 0;

        for (let i = 0; i < boids.length; i++) {
            if (distance(boid, boids[i]) < avoidenceRange && boid.name != boids[i].name) {
                avoidenceX += boid.x - boids[i].x;
                avoidenceY += boid.y - boids[i].y;

            }
        }

        boid.dx += avoidenceX * avoidenceWeight;
        boid.dy += avoidenceY * avoidenceWeight;
    }

    const alignment = (boid) => {
        let avgdx = 0;
        let avgdy = 0;
        let amt = 0;

        for (let i = 0; i < boids.length; i++) {
            if (distance(boid, boids[i]) < alignmentRange && boid.name != boids[i].name) {
                avgdx += boids[i].dx;
                avgdy += boids[i].dy;
                amt++;
            }
        }

        if (amt > 0) {
            avgdx = avgdx / amt;
            avgdy = avgdy / amt;
            boid.dx += ((avgdx - boid.dx) * alignmentWeight);
            boid.dy += ((avgdy - boid.dy) * alignmentWeight);
        }
    }

    const normalizeSpeed = (boid) => {
        let speed = Math.sqrt(Math.pow(boid.dx, 2) + Math.pow(boid.dy, 2));
        if (speed > boid.speed) {
            boid.dx *= boid.speed / speed;
            boid.dy *= boid.speed / speed;
        }
    }

    const dontLeave = (boid) => {
        const bounds = 5;

        if (boid.x < bounds) {
            boid.dx += 1;
        }
        else if (boid.x > c.width - bounds) {
            boid.dx -= 1;
        }

        if (boid.y < bounds) {
            boid.dy += 1;
        }
        else if (boid.y > c.height - bounds) {
            boid.dy -= 1;
        }
    }

    const avoidMouse = (boid) => {
        if (distance(boid, mouse) < 100) {
            boid.dx += (boid.x - mouse.x) * 0.025;
            boid.dy += (boid.y - mouse.y) * 0.025;
        }
    }

    const processBoid = (boid) => {
        cohesion(boid);
        avoidence(boid);
        alignment(boid);
        avoidMouse(boid);
        normalizeSpeed(boid);
        dontLeave(boid);

        boid.x += boid.dx;
        boid.y += boid.dy;
        boid.rot = rad2deg(Math.atan2(boid.dy, boid.dx));
    }

    const rad2deg = (rad) => {
        return rad * 180 / Math.PI;
    }

    const deg2rad = (deg) => {
        return deg * Math.PI / 180;
    }

    var boids = initBoids(500);

    const loop = () => {
        ctx.clearRect(0, 0, c.width, c.height);

        for (let i = 0; i < boidAmount; i++) {
            processBoid(boids[i]);
            drawBoid(boids[i]);
        }
        window.requestAnimationFrame(loop);
        console.log(cohesionWeight, alignmentWeight, avoidenceWeight);
    }

    window.requestAnimationFrame(loop);

</script>
<br>
<hr/>

## The Boid Algorithm
The simulation above is a simple implementation of boids in javascript using an HTML5 canvas. The algorithm, as mentioned above, employs a combination of three behaviors: avoidence, cohesion, and alignment. First, the algorithm initializes the boids:
<img src="https://raw.githubusercontent.com/gkgkgkgk/gkgkgkgk.github.io/gh-pages/_posts/assets/boids/initcode.png" width="75%" style="display: block; margin-left: auto; margin-right: auto; width: 75%;"/>
As shown above, boids are initialized with a random position and a random velocity (the x component of velocity is represented by dx, while the y component is represented by dy). The algorithm then iterates through each boid and applies the three behaviors by adjusting the velocity of each boid.

Below is some pseudocode for the three behaviors:

**Cohesion:**

Cohesion calculates the average position of all the surrounding boids and instructs the current boid to move towards that average position. This causes large groups of boids to stay together and form a cohesive flock.
<img src="https://raw.githubusercontent.com/gkgkgkgk/gkgkgkgk.github.io/gh-pages/_posts/assets/boids/cohesioncode.png" width="75%" style="display: block; margin-left: auto; margin-right: auto; width: 75%;"/>

**Avoidence**:

Avoidence moves the boid away from other boids that are too close to it, which prevents boids from crashing into each other. 
<img src="https://raw.githubusercontent.com/gkgkgkgk/gkgkgkgk.github.io/gh-pages/_posts/assets/boids/avoidencecode.png" width="75%" style="display: block; margin-left: auto; margin-right: auto; width: 75%;"/>

**Alignment**:

Alignment causes the boid to move in the direction of the average velocity of all the surrounding boids. This also allows boids to easily stay together and form a flock.

<img src="https://raw.githubusercontent.com/gkgkgkgk/gkgkgkgk.github.io/gh-pages/_posts/assets/boids/alignmentcode.png" width="75%" style="display: block; margin-left: auto; margin-right: auto; width: 75%;"/>
<br>

A few more steps are done in order to make the boids behave correctly, such as normalizing their velocity so that they don't move too fast as well as preventing them from leaving the canvas. Additionally, a velocity is applied to them if they are close to the mouse, causing them to run away from your mouse.

Once I finished a basic boid algorithm, I moved on to apply it in other scenarios.

## Another Boid simulation, but with a twist
Boids are pretty fun to watch and play around with, so just for the fun of it, I set up another simulation with some extra rules which allow groups of boids to fight each other (think Boid Warsâ„¢). In the simulation below, boids are grouped together and assigned a color. Boids in the same group will try to stay together and follow their group leader. The group leader is responsible for leading the group towards the nearest enemy group. Finally, boids can fire little bullets at each other, and if a boid is hit by a bullet, it dies. Additionally, each group is assigned a random interval for how often they can retarget their enemy and adjust their route, just to keep things interesting. Don't forget to click the start button below in order to kick off the simulation. *Warning: this simulation can be very intensive with a lot of boids. Please use a smaller amount of boids if you don't want to crash your browser.*

<canvas id="myCanvas2" width="500" height="500" style="border:1px solid #000000;">
</canvas>
<div style="display: flex; align-content: space-between;">
    <span>Amount of Squads</span><input type="range" min="1" max="20" value="5"
        oninput="changeSquadAmount(this.value)" />
    <span>Amount of Boids</span>
    <input type="range" min="1" max="50" value="5" oninput="changeBoidAmountSquad(this.value)" />
    <button onclick="start()">Start</button>
</div>

<script>
    var c2 = document.getElementById("myCanvas2");
    var ctx2 = c2.getContext("2d");

    let cohesionWeightSquad = 0.005;
    let alignmentWeightSquad = 0.01;
    let avoidenceWeightSquad = 0.01;
    let avoidenceRangeSquad = 20;

    let squadAmount = 5;
    let boidAmountSquad = 5;

    let bullets = [];

    const changeSquadAmount = (a) => {
        squadAmount = a;
    };

    const changeBoidAmountSquad = (a) => {
        boidAmountSquad = a;
    };

    const initBoidSquadrons = (amountOfSquads, amountOfBoids) => {
        let squads = [];
        for (let i = 0; i < amountOfSquads; i++) {
            let boids = [];
            let color = '#' + Math.floor(Math.random() * 16777215).toString(16);
            let leaderSteps = Math.floor(Math.random() * 10);

            for (let j = 0; j < amountOfBoids; j++) {
                let xPos = Math.random() * c.width;
                let yPos = Math.random() * c.height;
                let speed = 2;
                let dx = Math.random() * 10;
                let dy = Math.random() * 10;
                let rot = Math.atan2(dy, dx);

                boids.push({
                    name: "boid" + i + ":" + j,
                    squad: "squad" + i,
                    x: xPos,
                    y: yPos,
                    dx: dx,
                    dy: dy,
                    rot: rot,
                    speed: speed,
                    color: color,
                    fireRate: 20 + Math.floor(Math.random() * 100),
                    fireCounter: Math.floor(Math.random() * 20),
                });
            }

            let nearestSquad = i - 1;
            if (i < 0) {
                nearestSquad = amountOfSquads;
            }

            squads.push({
                name: "squad" + i,
                boids: boids,
                nearestSquad: nearestSquad,
                leaderSteps: leaderSteps,
                currentSteps: 0,
                dead: false
            });
        }

        return squads;
    }

    const drawBoidSquad = (boid) => {
        ctx2.save();
        ctx2.translate(boid.x, boid.y);
        ctx2.rotate(Math.atan2(boid.dy, boid.dx));
        ctx2.fillStyle = boid.color;
        ctx2.strokeStyle = boid.color;
        ctx2.beginPath();
        ctx2.moveTo(-3, 3);
        ctx2.lineTo(-3, -3);
        ctx2.lineTo(5, 0);

        ctx2.closePath();
        ctx2.stroke();
        ctx2.fill();
        ctx2.restore();
    }

    const drawBullet = (bullet) => {
        ctx2.save();
        ctx2.translate(bullet.x, bullet.y);
        ctx2.fillStyle = bullet.color;
        ctx2.strokeStyle = bullet.color;
        ctx2.beginPath();
        ctx2.arc(0, 0, 2, 0, 2 * Math.PI);
        ctx2.stroke();
        ctx2.fill();
        ctx2.restore();
    }

    const cohesionSquad = (boid, boidLeader) => {
        let cohesionX = boidLeader.x;
        let cohesionY = boidLeader.y;

        boid.dx += ((cohesionX - boid.x) * cohesionWeight);
        boid.dy += ((cohesionY - boid.y) * cohesionWeight);
    }

    const avoidenceSquad = (boid, boids) => {
        let avoidenceX = 0;
        let avoidenceY = 0;

        for (let i = 0; i < boids.length; i++) {
            if (distance(boid, boids[i]) < avoidenceRange && boid.name != boids[i].name) {
                avoidenceX += boid.x - boids[i].x;
                avoidenceY += boid.y - boids[i].y;

            }
        }

        boid.dx += avoidenceX * avoidenceWeight;
        boid.dy += avoidenceY * avoidenceWeight;
    }

    const alignmentSquad = (boid, leader) => {
        let avgdx = leader.dx;
        let avgdy = leader.dy;

        boid.dx += ((avgdx - boid.dx) * alignmentWeight);
        boid.dy += ((avgdy - boid.dy) * alignmentWeight);
    }

    const normalizeSpeedSquad = (boid) => {
        let speed = Math.sqrt(Math.pow(boid.dx, 2) + Math.pow(boid.dy, 2));
        if (speed > boid.speed) {
            boid.dx *= boid.speed / speed;
            boid.dy *= boid.speed / speed;
        }
    }

    const dontLeaveSquad = (boid) => {
        const bounds = 100;

        if (boid.x < bounds) {
            boid.dx += 1;
        }
        else if (boid.x > c.width - bounds) {
            boid.dx -= 1;
        }

        if (boid.y < bounds) {
            boid.dy += 1;
        }
        else if (boid.y > c.height - bounds) {
            boid.dy -= 1;
        }
    }

    const fire = (boid) => {
        let bullet = {
            boid: boid,
            dx: boid.dx,
            dy: boid.dy,
            x: boid.x,
            y: boid.y,
            speed: 5,
            color: boid.color
        }

        let speed = Math.sqrt(Math.pow(bullet.dx, 2) + Math.pow(bullet.dy, 2));
        bullet.dx /= speed;
        bullet.dy /= speed;

        bullets.push(bullet);
    }

    const processBoidSquad = (boid, boids) => {
        cohesionSquad(boid, boids[0]);
        avoidenceSquad(boid, allBoids);
        alignmentSquad(boid, boids[0]);
        normalizeSpeedSquad(boid);
        dontLeaveSquad(boid);

        if (boid.fireCounter > boid.fireRate) {
            boid.fireCounter = 0;
            fire(boid);
        }
        else {
            boid.fireCounter++;
        }

        boid.x += boid.dx;
        boid.y += boid.dy;
        boid.rot = rad2deg(Math.atan2(boid.dy, boid.dx));
    }

    const processSquadLeader = (squad) => {
        squad.currentSteps++;
        if (squad.currentSteps > squad.leaderSteps) {
            let nearestSquad = 0;

            let nearestPos = {
                x: 10000,
                y: 10000
            };

            for (let i = 0; i < squads.length; i++) {
                if (squad.name != squads[i].name) {
                    let avgPosX = 0;
                    let avgPosY = 0;
                    let amt = 0;

                    for (let j = 0; j < squads[i].boids.length; j++) {
                        avgPosX += squads[i].boids[j].x;
                        avgPosY += squads[i].boids[j].y;
                        amt++;
                    }

                    avgPosX = avgPosX / amt;
                    avgPosY = avgPosY / amt;

                    if (distance({ x: avgPosX, y: avgPosY }, squad.boids[0]) < distance({ x: nearestPos.x, y: nearestPos.y }, squad.boids[0])) {
                        nearestPos = { x: avgPosX, y: avgPosY };
                        squad.nearestSquad = squads[i];
                    }
                }
            }

            squad.boids[0].dx += ((nearestPos.x - squad.boids[0].x) * cohesionWeight);
            squad.boids[0].dy += ((nearestPos.y - squad.boids[0].y) * cohesionWeight);
            squad.currentSteps = 0;
        }

        dontLeaveSquad(squad.boids[0]);
        normalizeSpeedSquad(squad.boids[0]);
        squad.boids[0].x += squad.boids[0].dx;
        squad.boids[0].y += squad.boids[0].dy;
    }

    const processBullet = (bullet, i) => {
        bullet.x += bullet.dx * bullet.speed;
        bullet.y += bullet.dy * bullet.speed;

        if (bullet.x > c.width || bullet.x < 0 || bullet.y > c.height || bullet.y < 0) {
            bullets.splice(i, 1);
        }

        for (let j = 0; j < squads.length; j++) {
            if (bullet.boid.squad != squads[j].name) {
                for (let k = 1; k < squads[j].boids.length; k++) {
                    if (distance(bullet, squads[j].boids[k]) < 3) {
                        bullets.splice(i, 1);
                        squads[j].boids.splice(k, 1);
                    }
                }
            }
        }
    }

    var squads = [];
    var allBoids = [];



    const start = () => {
        allBoids = [];
        squads = [];
        squads = initBoidSquadrons(squadAmount, boidAmount);
        for (let i = 0; i < squads.length; i++) {
            for (let j = 0; j < squads[i].boids.length; j++) {
                allBoids.push(squads[i].boids[j]);
            }
        }
    }

    const loopSquad = () => {
        ctx2.clearRect(0, 0, c.width, c.height);
        for (let i = 0; i < squads.length; i++) {
            if (!squads[i].dead) {
                processSquadLeader(squads[i]);
                drawBoidSquad(squads[i].boids[0]);
                if (squads[i].boids.length == 1) {
                    squads[i].dead = true;
                }
                for (let j = 1; j < squads[i].boids.length; j++) {
                    if (squads[i].boids[j]) {
                        processBoidSquad(squads[i].boids[j], squads[i].boids);
                        drawBoidSquad(squads[i].boids[j]);
                    }
                }
            }
        }

        for (let i = 0; i < bullets.length; i++) {
            if (bullets[i]) {
                drawBullet(bullets[i]);
                processBullet(bullets[i], i);
            }
        }

        window.requestAnimationFrame(loopSquad);
    }

    window.requestAnimationFrame(loopSquad);

</script>
<br>
<hr/>
<br>

## So, why do I care about boids?

I started this project partially because I was intrigued by boids, but mostly because of the potential oppurtunity to learn about **compute shaders**. Compute shaders are a way to write code that runs directly on the GPU, allowing certain processes to be performed extremely quickly. Compute shaders are great for performing a massive amount of simple tasks in parallel, such as calculating the position of a boid.

I began by implementing boids in Unity3D using a simple CPU-based implementation. I then implemented the same boids in a GPU-based implementation using a compute shader. The CPU code is pretty similar to the code I showed above, so I will mainly focus on the compute shader code (which happens to also be pretty similar).

The compute shader begins by declaring the entry point to the program, allowing other scripts to be able to access it:
```#pragma kernel CSMain```

Next, I declare a struct that can hold a boid's position and velocity, as well as a buffer that can hold a list of boids.

<img src="https://raw.githubusercontent.com/gkgkgkgk/gkgkgkgk.github.io/gh-pages/_posts/assets/boids/computecode1.png" width="75%" style="display: block; margin-left: auto; margin-right: auto; width: 75%;"/>

After that, I can tell the compute shader to accept some parameters, such as the number of boids to calculate, their speed, and more.

<img src="https://raw.githubusercontent.com/gkgkgkgk/gkgkgkgk.github.io/gh-pages/_posts/assets/boids/computecode2.png" width="75%" style="display: block; margin-left: auto; margin-right: auto; width: 75%;"/>

Finally, I run the boid algorithm in the CSMain function of the compute shader. We can specify the dimensions of the thread groups, which dictates how many threads will be in each group running at once.

The rest of the shader is pretty much the same, with minimal syntax differences.

<img src="https://raw.githubusercontent.com/gkgkgkgk/gkgkgkgk.github.io/gh-pages/_posts/assets/boids/computecode3.png" width="75%" style="display: block; margin-left: auto; margin-right: auto; width: 75%;"/>

## Did it work?
The whole point of this project was to learn about compute shaders in order to improve the performance of the boid algorithm, and eventually the performance of other algorithms too.

I implemented three boid algorithms in Unity3D: a CPU implementation, a GPU implementation using a compute shader, and a GPU implementation that uses a compute shader as well as GPU instancing to draw the boids.
<br>
<hr/>
#### Tangent: GPU Instancing
GPU instancing is a way to draw multiple copies of a mesh using the GPU. It is highly efficient, and can be used to draw a large number of objects at once, which is perfect for drawing boids.
<hr/>
<br>

Anyway, these three implementations proved to me that compute shaders are a great way to speed up certain algorithms. Below is a graph that shows the performance of the three boid algorithms.

<img src="https://raw.githubusercontent.com/gkgkgkgk/gkgkgkgk.github.io/gh-pages/_posts/assets/boids/boidsfpschart.png" width="80%" style="display: block; margin-left: auto; margin-right: auto; width: 80%;"/>
<br>

* With **100** boids, they all performed at high speeds, with the GPU instancing implementation being the fastest at over 600 fps. 
* Once there were over **1000** boids, the CPU implementation started to fail, and would run at an average of 8.7 fps. Both GPU implementations were still running strong, with average frame rates of 94 fps and 625.6 fps.
* Finally, with **10000** boids, the CPU and GPU implementations were rendered useless, with average frame rates of 0.1 fps and 1.5 fps respectively. With that amount of boids, the GPU instancing implementation held its own at an average 87.9 fps!

## The bottom line
Compute shaders and running algorithms on the GPU are great ways of increasing performence and working with large amounts of objects. I am extremely excited about learning how to use compute shaders, and I can't wait to use them in upcoming projects (I think that using them in [dynamic LOD meshes](https://gkgkgkgk.github.io/unity/2021/11/17/quadtrees.html) is a great way to improve the performance of the algorithm).

Thanks for reading!
<img src="https://raw.githubusercontent.com/gkgkgkgk/gkgkgkgk.github.io/gh-pages/_posts/assets/boids/biggif.gif" width="75%" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

## Resources
 * Thank you to Sebastian Lague for his [awesome video on compute shaders](https://www.youtube.com/watch?v=9RHGLZLUuwc&t=199s&ab_channel=SebastianLague)!
 * [Unity Docs for Compute Shaders](https://docs.unity3d.com/Manual/class-ComputeShader.html)
 * Thank you to Ben Eater and his [great tutorial on boids](https://eater.net/boids)!
 * [Wikipedia on boids](https://en.wikipedia.org/wiki/Boids)
 * Really helpful [pseudocode for boids](http://www.kfish.org/boids/pseudocode.html).
 * My code for this project is [here](https://github.com/gkgkgkgk/TatooTwo/tree/main/Boids)!