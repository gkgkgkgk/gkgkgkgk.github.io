---
layout: post
title: "Working title about BOIDS"
date: 2021-12-27 8:00:00 -0000
categories: shaders
featured-image: https://raw.githubusercontent.com/gkgkgkgk/gkgkgkgk.github.io/gh-pages/_posts/assets/nodesql/filter.png
---

# What are Boids?
The word Boid comes from a shortened version of "bird-oid object", a term to describe a bird-like object. Similar to how real birds are programmed, each boid must follow these rules:
* Alignment: every boid attempts to fly in the same direction as other nearby boids
* Cohesion: boids attempt to stay together
* Avoidance: boids try not to crash into each other

The actual algorithm will be discussed in depth later on. Before I jump into the technical details, let's take a look at some boids in action! The simulation below is a very simple implementation of boids. Feel free to play around with it to see what each of the sliders do!

<head>
    <link rel="stylesheet" href="styles.css">
</head>
<canvas id="myCanvas" width="500" height="500" style="border:1px solid #000000;">
</canvas>

<div>
    <h3>Amount of Boids</h3>
    <div class='sliderContainer'>
        <input type="range" min="0" max="500" value="50" oninput="changeBoidAmount(this.value)" />
    </div>
</div>

<div>
    <h3>Cohesion</h3>
    <div class='sliderContainer'>
        <span class='slider' id="cohesion">Weight</span>
        <input type="range" min="0" max="50" value="5" oninput="changeCohesionWeight(this.value)" />
        <span class='slider' id="cohesion">Range</span>
        <input type="range" min="1" max="750" value="250" oninput="changeCohesionRange(this.value)" />
    </div>
</div>

<div>
    <h3>Alignment</h3>
    <div class='sliderContainer'>
        <span class='slider'>Weight</span>
        <input type="range" min="0" max="50" value="5" oninput="changeAlignmentWeight(this.value)" />
        <span class='slider'>Range</span>
        <input type="range" min="1" max="750" value="250" oninput="changeAlignmentRange(this.value)" />
    </div>
</div>

<div>
    <h3>Avoidence</h3>
    <div class='sliderContainer'>
        <span class='slider'>Weight</span>
        <input type="range" min="0" max="500" value="50" oninput="changeAvoidenceWeight(this.value)" />
        <span class='slider'>Range</span>
        <input type="range" min="1" max="50" value="20" oninput="changeAvoidenceRange(this.value)" />
    </div>
</div>

<script>
    var c = document.getElementById("myCanvas");
    var ctx = c.getContext("2d");

    var mouse = {
        x: undefined,
        y: undefined
    };

    c.addEventListener("mousemove", function (e) {
        mouse.x = e.x;
        mouse.y = e.y;
        var rect = c.getBoundingClientRect();
        mouse.x -= rect.left;
        mouse.y -= rect.top;
    });

    let cohesionWeight = 0.0025;
    const changeCohesionWeight = (cohesion) => {
        cohesionWeight = cohesion / 1000;
    };

    let cohesionRange = 250;
    const changeCohesionRange = (cohesion) => {
        cohesionRange = cohesion;
    };

    let alignmentWeight = 0.026;
    const changeAlignmentWeight = (alignment) => {
        alignmentWeight = alignment / 1000;
    };

    let alignmentRange = 25;
    const changeAlignmentRange = (alignment) => {
        alignmentRange = alignment;
    };

    let avoidenceWeight = 0.104;
    const changeAvoidenceWeight = (avoidence) => {
        avoidenceWeight = avoidence / 1000;
    };

    let avoidenceRange = 5;
    const changeAvoidenceRange = (avoidence) => {
        avoidenceRange = avoidence;
    };

    let boidAmount = 100;
    const changeBoidAmount = (amt) => {
        boidAmount = amt;
    };

    const initBoids = (amount) => {
        let boids = [];
        for (let i = 0; i < amount; i++) {
            let xPos = Math.random() * c.width;
            let yPos = Math.random() * c.height;
            let speed = 1;
            let dx = Math.random() * 20 - 10;
            let dy = Math.random() * 20 - 10;
            let rot = Math.atan2(dy, dx);

            boids.push({
                name: "boid" + i,
                x: xPos,
                y: yPos,
                dx: dx,
                dy: dy,
                rot: rot,
                speed: speed,
                color: '#' + Math.floor(Math.random() * 16777215).toString(16)
            });
        }

        return boids;
    }

    const drawBoid = (boid) => {
        ctx.save();
        ctx.translate(boid.x, boid.y);
        ctx.rotate(Math.atan2(boid.dy, boid.dx));
        ctx.beginPath();
        ctx.moveTo(-2, 2);
        ctx.lineTo(-2, -2);
        ctx.lineTo(4, 0);

        ctx.closePath();
        ctx.stroke();
        ctx.fill();
        ctx.restore();
    }

    const distance = (boid1, boid2) => {
        return Math.sqrt(Math.pow(boid1.x - boid2.x, 2) + Math.pow(boid1.y - boid2.y, 2));
    }

    const cohesion = (boid) => {
        let cohesionX = 0;
        let cohesionY = 0;
        let amt = 0;

        for (let i = 0; i < boids.length; i++) {
            if (distance(boid, boids[i]) < cohesionRange && boid.name != boids[i].name) {
                cohesionX += boids[i].x;
                cohesionY += boids[i].y;
                amt++;
            }
        }

        if (amt > 0) {
            cohesionX = cohesionX / amt;
            cohesionY = cohesionY / amt;
            boid.dx += ((cohesionX - boid.x) * cohesionWeight);
            boid.dy += ((cohesionY - boid.y) * cohesionWeight);
        }
    }

    const avoidence = (boid) => {
        let avoidenceX = 0;
        let avoidenceY = 0;

        for (let i = 0; i < boids.length; i++) {
            if (distance(boid, boids[i]) < avoidenceRange && boid.name != boids[i].name) {
                avoidenceX += boid.x - boids[i].x;
                avoidenceY += boid.y - boids[i].y;

            }
        }

        boid.dx += avoidenceX * avoidenceWeight;
        boid.dy += avoidenceY * avoidenceWeight;
    }

    const alignment = (boid) => {
        let avgdx = 0;
        let avgdy = 0;
        let amt = 0;

        for (let i = 0; i < boids.length; i++) {
            if (distance(boid, boids[i]) < alignmentRange && boid.name != boids[i].name) {
                avgdx += boids[i].dx;
                avgdy += boids[i].dy;
                amt++;
            }
        }

        if (amt > 0) {
            avgdx = avgdx / amt;
            avgdy = avgdy / amt;
            boid.dx += ((avgdx - boid.dx) * alignmentWeight);
            boid.dy += ((avgdy - boid.dy) * alignmentWeight);
        }
    }

    const normalizeSpeed = (boid) => {
        let speed = Math.sqrt(Math.pow(boid.dx, 2) + Math.pow(boid.dy, 2));
        if (speed > boid.speed) {
            boid.dx *= boid.speed / speed;
            boid.dy *= boid.speed / speed;
        }
    }

    const dontLeave = (boid) => {
        const bounds = 5;

        if (boid.x < bounds) {
            boid.dx += 1;
        }
        else if (boid.x > c.width - bounds) {
            boid.dx -= 1;
        }

        if (boid.y < bounds) {
            boid.dy += 1;
        }
        else if (boid.y > c.height - bounds) {
            boid.dy -= 1;
        }
    }

    const avoidMouse = (boid) => {
        if (distance(boid, mouse) < 100) {
            boid.dx += (boid.x - mouse.x) * 0.025;
            boid.dy += (boid.y - mouse.y) * 0.025;
        }
    }

    const processBoid = (boid) => {
        cohesion(boid);
        avoidence(boid);
        alignment(boid);
        avoidMouse(boid);
        normalizeSpeed(boid);
        dontLeave(boid);

        boid.x += boid.dx;
        boid.y += boid.dy;
        boid.rot = rad2deg(Math.atan2(boid.dy, boid.dx));
    }

    const rad2deg = (rad) => {
        return rad * 180 / Math.PI;
    }

    const deg2rad = (deg) => {
        return deg * Math.PI / 180;
    }

    var boids = initBoids(500);

    const loop = () => {
        ctx.clearRect(0, 0, c.width, c.height);

        for (let i = 0; i < boidAmount; i++) {
            processBoid(boids[i]);
            drawBoid(boids[i]);
        }
        window.requestAnimationFrame(loop);
        console.log(cohesionWeight, alignmentWeight, avoidenceWeight);
    }

    window.requestAnimationFrame(loop);

</script>
<br>

Boids are pretty fun to watch and play around with, so just for the fun of it, I set up another simulation with some extra rules. In the simulation below, boids are grouped into "squads", and each squad is assigned a color. Boids in the same squad will try to stay together and target the nearest squad. Boids can fire little bullets at each other, and if it by a bullet, the boid will die.

<canvas id="myCanvas2" width="500" height="500" style="border:1px solid #000000;">
</canvas>
<div style="display: flex; align-content: space-between;">
    <span>Amount of Squads</span><input type="range" min="1" max="20" value="5"
        oninput="changeSquadAmount(this.value)" />
    <span>Amount of Boids</span>
    <input type="range" min="1" max="50" value="5" oninput="changeBoidAmountSquad(this.value)" />
    <button onclick="start()">Start</button>
</div>

<script>
    var c2 = document.getElementById("myCanvas2");
    var ctx2 = c2.getContext("2d");

    let cohesionWeightSquad = 0.005;
    let alignmentWeightSquad = 0.01;
    let avoidenceWeightSquad = 0.01;
    let avoidenceRangeSquad = 20;

    let squadAmount = 5;
    let boidAmountSquad = 5;

    let bullets = [];

    const changeSquadAmount = (a) => {
        squadAmount = a;
    };

    const changeBoidAmountSquad = (a) => {
        boidAmountSquad = a;
    };

    const initBoidSquadrons = (amountOfSquads, amountOfBoids) => {
        let squads = [];
        for (let i = 0; i < amountOfSquads; i++) {
            let boids = [];
            let color = '#' + Math.floor(Math.random() * 16777215).toString(16);
            let leaderSteps = Math.floor(Math.random() * 10);

            for (let j = 0; j < amountOfBoids; j++) {
                let xPos = Math.random() * c.width;
                let yPos = Math.random() * c.height;
                let speed = 2;
                let dx = Math.random() * 10;
                let dy = Math.random() * 10;
                let rot = Math.atan2(dy, dx);

                boids.push({
                    name: "boid" + i + ":" + j,
                    squad: "squad" + i,
                    x: xPos,
                    y: yPos,
                    dx: dx,
                    dy: dy,
                    rot: rot,
                    speed: speed,
                    color: color,
                    fireRate: 20 + Math.floor(Math.random() * 100),
                    fireCounter: Math.floor(Math.random() * 20),
                });
            }

            let nearestSquad = i - 1;
            if (i < 0) {
                nearestSquad = amountOfSquads;
            }

            squads.push({
                name: "squad" + i,
                boids: boids,
                nearestSquad: nearestSquad,
                leaderSteps: leaderSteps,
                currentSteps: 0,
                dead: false
            });
        }

        return squads;
    }

    const drawBoidSquad = (boid) => {
        ctx2.save();
        ctx2.translate(boid.x, boid.y);
        ctx2.rotate(Math.atan2(boid.dy, boid.dx));
        ctx2.fillStyle = boid.color;
        ctx2.strokeStyle = boid.color;
        ctx2.beginPath();
        ctx2.moveTo(-3, 3);
        ctx2.lineTo(-3, -3);
        ctx2.lineTo(5, 0);

        ctx2.closePath();
        ctx2.stroke();
        ctx2.fill();
        ctx2.restore();
    }

    const drawBullet = (bullet) => {
        ctx2.save();
        ctx2.translate(bullet.x, bullet.y);
        ctx2.fillStyle = bullet.color;
        ctx2.strokeStyle = bullet.color;
        ctx2.beginPath();
        ctx2.arc(0, 0, 2, 0, 2 * Math.PI);
        ctx2.stroke();
        ctx2.fill();
        ctx2.restore();
    }

    const cohesionSquad = (boid, boidLeader) => {
        let cohesionX = boidLeader.x;
        let cohesionY = boidLeader.y;

        boid.dx += ((cohesionX - boid.x) * cohesionWeight);
        boid.dy += ((cohesionY - boid.y) * cohesionWeight);
    }

    const avoidenceSquad = (boid, boids) => {
        let avoidenceX = 0;
        let avoidenceY = 0;

        for (let i = 0; i < boids.length; i++) {
            if (distance(boid, boids[i]) < avoidenceRange && boid.name != boids[i].name) {
                avoidenceX += boid.x - boids[i].x;
                avoidenceY += boid.y - boids[i].y;

            }
        }

        boid.dx += avoidenceX * avoidenceWeight;
        boid.dy += avoidenceY * avoidenceWeight;
    }

    const alignmentSquad = (boid, leader) => {
        let avgdx = leader.dx;
        let avgdy = leader.dy;

        boid.dx += ((avgdx - boid.dx) * alignmentWeight);
        boid.dy += ((avgdy - boid.dy) * alignmentWeight);
    }

    const normalizeSpeedSquad = (boid) => {
        let speed = Math.sqrt(Math.pow(boid.dx, 2) + Math.pow(boid.dy, 2));
        if (speed > boid.speed) {
            boid.dx *= boid.speed / speed;
            boid.dy *= boid.speed / speed;
        }
    }

    const dontLeaveSquad = (boid) => {
        const bounds = 100;

        if (boid.x < bounds) {
            boid.dx += 1;
        }
        else if (boid.x > c.width - bounds) {
            boid.dx -= 1;
        }

        if (boid.y < bounds) {
            boid.dy += 1;
        }
        else if (boid.y > c.height - bounds) {
            boid.dy -= 1;
        }
    }

    const fire = (boid) => {
        let bullet = {
            boid: boid,
            dx: boid.dx,
            dy: boid.dy,
            x: boid.x,
            y: boid.y,
            speed: 5,
            color: boid.color
        }

        let speed = Math.sqrt(Math.pow(bullet.dx, 2) + Math.pow(bullet.dy, 2));
        bullet.dx /= speed;
        bullet.dy /= speed;

        bullets.push(bullet);
    }

    const processBoidSquad = (boid, boids) => {
        cohesionSquad(boid, boids[0]);
        avoidenceSquad(boid, allBoids);
        alignmentSquad(boid, boids[0]);
        normalizeSpeedSquad(boid);
        dontLeaveSquad(boid);

        if (boid.fireCounter > boid.fireRate) {
            boid.fireCounter = 0;
            fire(boid);
        }
        else {
            boid.fireCounter++;
        }

        boid.x += boid.dx;
        boid.y += boid.dy;
        boid.rot = rad2deg(Math.atan2(boid.dy, boid.dx));
    }

    const processSquadLeader = (squad) => {
        squad.currentSteps++;
        if (squad.currentSteps > squad.leaderSteps) {
            let nearestSquad = 0;

            let nearestPos = {
                x: 10000,
                y: 10000
            };

            for (let i = 0; i < squads.length; i++) {
                if (squad.name != squads[i].name) {
                    let avgPosX = 0;
                    let avgPosY = 0;
                    let amt = 0;

                    for (let j = 0; j < squads[i].boids.length; j++) {
                        avgPosX += squads[i].boids[j].x;
                        avgPosY += squads[i].boids[j].y;
                        amt++;
                    }

                    avgPosX = avgPosX / amt;
                    avgPosY = avgPosY / amt;

                    if (distance({ x: avgPosX, y: avgPosY }, squad.boids[0]) < distance({ x: nearestPos.x, y: nearestPos.y }, squad.boids[0])) {
                        nearestPos = { x: avgPosX, y: avgPosY };
                        squad.nearestSquad = squads[i];
                    }
                }
            }

            squad.boids[0].dx += ((nearestPos.x - squad.boids[0].x) * cohesionWeight);
            squad.boids[0].dy += ((nearestPos.y - squad.boids[0].y) * cohesionWeight);
            squad.currentSteps = 0;
        }

        dontLeaveSquad(squad.boids[0]);
        normalizeSpeedSquad(squad.boids[0]);
        squad.boids[0].x += squad.boids[0].dx;
        squad.boids[0].y += squad.boids[0].dy;
    }

    const processBullet = (bullet, i) => {
        bullet.x += bullet.dx * bullet.speed;
        bullet.y += bullet.dy * bullet.speed;

        if (bullet.x > c.width || bullet.x < 0 || bullet.y > c.height || bullet.y < 0) {
            bullets.splice(i, 1);
        }

        for (let j = 0; j < squads.length; j++) {
            if (bullet.boid.squad != squads[j].name) {
                for (let k = 1; k < squads[j].boids.length; k++) {
                    if (distance(bullet, squads[j].boids[k]) < 3) {
                        bullets.splice(i, 1);
                        squads[j].boids.splice(k, 1);
                    }
                }
            }
        }
    }

    var squads = [];
    var allBoids = [];



    const start = () => {
        allBoids = [];
        squads = [];
        squads = initBoidSquadrons(squadAmount, boidAmount);
        for (let i = 0; i < squads.length; i++) {
            for (let j = 0; j < squads[i].boids.length; j++) {
                allBoids.push(squads[i].boids[j]);
            }
        }
    }

    const loopSquad = () => {
        ctx2.clearRect(0, 0, c.width, c.height);
        for (let i = 0; i < squads.length; i++) {
            if (!squads[i].dead) {
                processSquadLeader(squads[i]);
                drawBoidSquad(squads[i].boids[0]);
                if (squads[i].boids.length == 1) {
                    squads[i].dead = true;
                }
                for (let j = 1; j < squads[i].boids.length; j++) {
                    if (squads[i].boids[j]) {
                        processBoidSquad(squads[i].boids[j], squads[i].boids);
                        drawBoidSquad(squads[i].boids[j]);
                    }
                }
            }
        }

        for (let i = 0; i < bullets.length; i++) {
            if (bullets[i]) {
                drawBullet(bullets[i]);
                processBullet(bullets[i], i);
            }
        }

        window.requestAnimationFrame(loopSquad);
    }

    window.requestAnimationFrame(loopSquad);

</script>
<br>